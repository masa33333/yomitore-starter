'use client';

import { useState, useEffect, Suspense } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { getNextCity, getNextUnreachedCity } from '@/lib/getNextCity';
import { letters } from '@/app/data/letterData';
import { getEnglishText } from '@/utils/getEnglishText';
import { getLetterFromStorage } from '@/lib/letterStorage';
import { saveToHistory } from '@/lib/saveToHistory';

function LetterPageContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [showNotice, setShowNotice] = useState(false);
  const [diary, setDiary] = useState<any>(null);
  const [letterText, setLetterText] = useState<string>('');
  const [cityImage, setCityImage] = useState<string>('');
  const [wordCount, setWordCount] = useState<number>(0);
  const [cityName, setCityName] = useState<string>('');
  const [hasStarted, setHasStarted] = useState<boolean>(false);
  const [isCompleted, setIsCompleted] = useState<boolean>(false);
  const [showTranslation, setShowTranslation] = useState<boolean>(false);
  const [diaryNotFound, setDiaryNotFound] = useState<boolean>(false);
  const [startTime, setStartTime] = useState<number | null>(null);
  const [endTime, setEndTime] = useState<number | null>(null);
  const [calculatedWPM, setCalculatedWPM] = useState<number>(0);
  
  // Dictionary functionality states
  const [wordInfo, setWordInfo] = useState<any>(null);
  const [loadingWordInfo, setLoadingWordInfo] = useState(false);
  const [sessionWords, setSessionWords] = useState<any[]>([]);
  const [definitionLanguage, setDefinitionLanguage] = useState<'ja' | 'en'>('ja');
  const [loadingTranslation, setLoadingTranslation] = useState(false);
  const [selectedWord, setSelectedWord] = useState<string | null>(null);
  const [showDictionaryModal, setShowDictionaryModal] = useState(false);
  const [clickedWords, setClickedWords] = useState<any[]>([]);

  // ÂìÅË©û„ÅÆÊó•Êú¨Ë™û„Éû„ÉÉ„Éî„É≥„Ç∞
  const posMap: Record<string, string> = {
    v: "ÂãïË©û",
    n: "ÂêçË©û", 
    adj: "ÂΩ¢ÂÆπË©û",
    adv: "ÂâØË©û",
    prep: "ÂâçÁΩÆË©û",
    conj: "Êé•Á∂öË©û",
    pron: "‰ª£ÂêçË©û",
    int: "ÈñìÊäïË©û",
    unknown: "‰∏çÊòé"
  };

  // Dictionary functionality functions
  const saveWordToNotebook = (wordInfo: any) => {
    try {
      const existingNotebook = JSON.parse(localStorage.getItem('myNotebook') || '[]');
      
      const isDuplicate = existingNotebook.some(
        (item: any) => item.word.toLowerCase() === wordInfo.word.toLowerCase()
      );
      
      if (!isDuplicate) {
        existingNotebook.push(wordInfo);
        localStorage.setItem('myNotebook', JSON.stringify(existingNotebook));
        console.log('üìù ÂçòË™û„Çí„Éé„Éº„Éà„Éñ„ÉÉ„ÇØ„Å´‰øùÂ≠ò:', wordInfo.word);
        return true;
      } else {
        console.log('üìù ÂçòË™û„ÅØÊó¢„Å´„Éé„Éº„Éà„Éñ„ÉÉ„ÇØ„Å´Â≠òÂú®:', wordInfo.word);
        return false;
      }
    } catch (error) {
      console.error('„Éé„Éº„Éà„Éñ„ÉÉ„ÇØ‰øùÂ≠ò„Ç®„É©„Éº:', error);
      return false;
    }
  };

  const isWordInNotebook = (word: string): boolean => {
    try {
      const existingNotebook = JSON.parse(localStorage.getItem('myNotebook') || '[]');
      return existingNotebook.some(
        (item: any) => item.word.toLowerCase() === word.toLowerCase()
      );
    } catch (error) {
      console.error('„Éé„Éº„Éà„Éñ„ÉÉ„ÇØÁ¢∫Ë™ç„Ç®„É©„Éº:', error);
      return false;
    }
  };

  const getWordContext = (targetWord: string) => {
    const words = letterText.split(/\s+/);
    const targetIndex = words.findIndex(word => 
      word.toLowerCase().replace(/[^a-zA-Z]/g, '') === targetWord.toLowerCase()
    );
    
    if (targetIndex === -1) return letterText.slice(0, 100);
    
    const start = Math.max(0, targetIndex - 5);
    const end = Math.min(words.length, targetIndex + 6);
    return words.slice(start, end).join(' ');
  };

  const handleWordClick = async (word: string) => {
    const cleanWord = word.replace(/[^a-zA-Z]/g, '');
    if (cleanWord.length === 0) return;

    const headword = cleanWord.toLowerCase();
    
    // Check if word is already saved to avoid duplicates
    const isInNotebook = isWordInNotebook(headword);
    const isInClickedWords = clickedWords.some(w => w.word.toLowerCase() === headword.toLowerCase());
    
    if (isInNotebook || isInClickedWords) {
      console.log('üìù ÂçòË™û„ÅØÊó¢„Å´Ë®òÈå≤Ê∏à„Åø„ÄÅÂá¶ÁêÜ„Çí„Çπ„Ç≠„ÉÉ„Éó:', headword);
      return;
    }
    
    setSelectedWord(headword);
    
    // Visual feedback - add a subtle animation or highlight
    console.log('üìñ ÂçòË™û„Çí„ÇØ„É™„ÉÉ„ÇØ:', headword);
    
    try {
      console.log('üîç ËæûÊõ∏ÊÉÖÂ†±ÂèñÂæóÈñãÂßã:', headword);
      
      // Get context for the word
      const contextSentence = getWordContext(headword);
      console.log('üìÑ „Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÊñá:', contextSentence);
      
      let wordData = null;
      
      // Try context-word-analysis API first
      try {
        const response = await fetch('/api/context-word-analysis', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            word: headword,
            contextSentence: contextSentence,
            outputLanguage: 'japanese'
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('‚úÖ ËæûÊõ∏APIÂøúÁ≠î:', data);
          
          wordData = {
            word: data.word || headword,
            pos: data.pos || 'unknown',
            jaDefinition: data.meaning_ja || 'ÂÆöÁæ©„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì',
            enDefinition: data.meaning_en || 'Definition not available',
            jaExample: data.example_ja || '',
            enExample: data.example_en || '',
            baseForm: data.base || undefined
          };
        } else {
          console.log('‚ùå ËæûÊõ∏APIÂ§±Êïó:', response.status);
        }
      } catch (apiError) {
        console.error('ËæûÊõ∏APIÂëº„Å≥Âá∫„Åó„Ç®„É©„Éº:', apiError);
      }
      
      // Fallback to simple word info if API failed
      if (!wordData) {
        console.log('‚ö†Ô∏è API„ÅåÂà©Áî®„Åß„Åç„Å™„ÅÑ„Åü„ÇÅ„ÄÅÁ∞°ÊòìÊÉÖÂ†±„Çí‰ΩúÊàê');
        wordData = {
          word: headword,
          pos: 'unknown',
          jaDefinition: 'ÂÆöÁæ©„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì',
          enDefinition: 'Definition not available',
          jaExample: '',
          enExample: ''
        };
      }
      
      // Store in clicked words array (no modal during reading)
      setClickedWords(prev => [...prev, wordData]);
      
      // Also save to localStorage for notebook
      try {
        const existingClickedWords = JSON.parse(localStorage.getItem('clickedWords') || '[]');
        const updatedClickedWords = [...existingClickedWords, wordData];
        localStorage.setItem('clickedWords', JSON.stringify(updatedClickedWords));
        console.log('üíæ ÂçòË™û„ÇíclickedWords„Å´‰øùÂ≠ò:', headword);
      } catch (storageError) {
        console.error('localStorage‰øùÂ≠ò„Ç®„É©„Éº:', storageError);
      }
      
      // Keep existing notebook saving for compatibility
      const notebookInfo = {
        word: wordData.word,
        originalForm: cleanWord,
        partOfSpeech: wordData.pos,
        detailedPos: wordData.pos,
        meaning: wordData.enDefinition,
        japaneseMeaning: wordData.jaDefinition,
        sentence: wordData.enExample,
        sentenceJapanese: wordData.jaExample,
        baseForm: wordData.baseForm
      };
      
      saveWordToNotebook(notebookInfo);
      
      setSessionWords(prev => {
        const isDuplicate = prev.some(w => w.word.toLowerCase() === notebookInfo.word.toLowerCase());
        return isDuplicate ? prev : [...prev, notebookInfo];
      });

    } catch (error) {
      console.error('ÂçòË™ûÊÉÖÂ†±„ÅÆÂèñÂæó„Å´Â§±Êïó:', error);
      // Create fallback word info
      const fallbackData = {
        word: headword,
        pos: 'unknown',
        jaDefinition: 'ÂÆöÁæ©„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì',
        enDefinition: 'Definition not available',
        jaExample: '',
        enExample: ''
      };
      
      setClickedWords(prev => [...prev, fallbackData]);
      
      // Save fallback to localStorage as well
      try {
        const existingClickedWords = JSON.parse(localStorage.getItem('clickedWords') || '[]');
        const updatedClickedWords = [...existingClickedWords, fallbackData];
        localStorage.setItem('clickedWords', JSON.stringify(updatedClickedWords));
      } catch (storageError) {
        console.error('localStorage‰øùÂ≠ò„Ç®„É©„Éº:', storageError);
      }
    }
  };

  const showDefinition = async (word: string) => {
    await handleWordClick(word);
  };

  const splitWords = (text: string) =>
    text.split(/\b/).map((w, i) => (
      <span 
        key={i} 
        onClick={() => showDefinition(w)}
        className={/\w/.test(w) ? "cursor-pointer hover:bg-yellow-200 hover:rounded transition-colors" : ""}
        style={/\w/.test(w) ? { padding: '1px 2px' } : {}}
      >
        {w}
      </span>
    ));

  const renderClickableText = (text: string) => {
    return splitWords(text);
  };

  // ÈÉΩÂ∏ÇÂêçÂ§âÊèõ„Éû„ÉÉ„Éó
  const cityNameMap: { [key: string]: string } = {
    'Êù±‰∫¨': 'Tokyo',
    '„É≠„É≥„Éâ„É≥': 'London',
    '„Éã„É•„Éº„É®„Éº„ÇØ': 'New York',
    '„Éä„Ç§„É≠„Éì': 'Nairobi',
    '„Ç∑„Éâ„Éã„Éº': 'Sydney',
    'Tokyo': 'Tokyo',
    'London': 'London',
    'New York': 'New York',
    'Nairobi': 'Nairobi',
    'Sydney': 'Sydney'
  };


  // ‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„ÇãÊó•Ë®ò‰∏ÄË¶ß„ÇíÂèñÂæó
  const getAllDiaries = () => {
    try {
      const savedDiaries = localStorage.getItem('diaries');
      return savedDiaries ? JSON.parse(savedDiaries) : [];
    } catch (error) {
      console.error('Error parsing diaries from localStorage:', error);
      return [];
    }
  };

  // LocalStorageÂÑ™ÂÖà„ÅÆÊó•Ë®òÂèñÂæóÔºàÂç≥ÊôÇË°®Á§∫Áî®Ôºâ
  const getDiaryFromLocalStorage = (id: string) => {
    try {
      // 1. diary:id ÂΩ¢Âºè„ÅßÊ§úÁ¥¢
      const diaryKey = `diary:${id}`;
      const savedDiary = localStorage.getItem(diaryKey);
      
      if (savedDiary) {
        const parsedDiary = JSON.parse(savedDiary);
        console.log('‚ö° Found diary in localStorage (immediate):', parsedDiary);
        return parsedDiary;
      }

      // 2. ÊóßÂΩ¢Âºè: diariesÈÖçÂàó„Åã„ÇâÊ§úÁ¥¢
      const diaries = getAllDiaries();
      const foundDiary = diaries.find((d: any) => d.id === id);
      if (foundDiary) {
        console.log('‚ö° Found diary in diaries array (immediate):', foundDiary);
        return foundDiary;
      }

      console.log('‚ùå No diary found in localStorage for immediate display');
      return null;
    } catch (error) {
      console.error('Error getting diary from localStorage:', error);
      return null;
    }
  };

  // APIÂèñÂæóÔºà„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊõ¥Êñ∞Áî®Ôºâ
  const getDiaryFromAPI = async (id: string) => {
    try {
      console.log(`üåê Background fetching from API: /api/diary?id=${id}`);
      const response = await fetch(`/api/diary?id=${id}`);
      
      if (response.ok) {
        const data = await response.json();
        console.log('‚úÖ Background API Response:', data.diary);
        
        // API„Åã„ÇâÂèñÂæó„Åó„ÅüÊó•Ë®ò„ÇílocalStorage„Å´‰øùÂ≠ò
        if (data.diary) {
          localStorage.setItem(`diary:${id}`, JSON.stringify(data.diary));
          console.log('üíæ Updated localStorage with API data');
        }
        
        return data.diary;
      } else {
        console.log('‚ùå Background API response not ok:', response.status);
        return null;
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Background API fetch failed:', error);
      return null;
    }
  };

  const setDiaryData = (foundDiary: any) => {
    setDiary(foundDiary);
    const content = foundDiary.en || foundDiary.letterText || '';
    setLetterText(content);
    setCityName(foundDiary.location || cityNameMap[foundDiary.cityName] || 'Unknown');
    
    // Calculate word count from actual content
    const words = content.trim().split(/\s+/).filter((word: string) => word.length > 0);
    setWordCount(words.length);
    
    setCityImage(foundDiary.cityImage || `/letters/${foundDiary.id}.png`);
    setDiaryNotFound(false);
  };

  useEffect(() => {
    if (searchParams.get('new') === '1') {
      setShowNotice(true);
      const timer = setTimeout(() => setShowNotice(false), 5000);
      return () => clearTimeout(timer);
    }
    
    // üìß /letter „Éö„Éº„Ç∏„Å´ÈÅ∑Áßª„Åó„Åü„ÇâÈÄöÁü•„Éï„É©„Ç∞„Çí„ÇØ„É™„Ç¢
    localStorage.setItem('notified', 'false');
    console.log('üìß Letter page visited, cleared notified flag');
  }, [searchParams]);

  useEffect(() => {
    const loadDiary = async () => {
      // URL „Åã„Çâ id „ÇíÂèñÂæó
      const id = searchParams.get('id');
      console.log('üîç diary.id:', id);

      // üìß PRIORITY 1: Check for stored letter/mail content first
      const storedLetter = getLetterFromStorage();
      console.log('üìß Checking stored letter first:', storedLetter);
      
      if (storedLetter) {
        // Use stored letter/mail content
        const userLevel = parseInt(localStorage.getItem('vocabLevel') || '1', 10);
        let contentToShow = '';
        
        if (storedLetter.en && storedLetter.en[userLevel]) {
          contentToShow = storedLetter.en[userLevel];
        } else if (storedLetter.en) {
          // Use first available level if exact level not found
          const availableLevels = Object.keys(storedLetter.en).map(Number);
          if (availableLevels.length > 0) {
            contentToShow = storedLetter.en[availableLevels[0]];
          }
        }
        
        console.log('üìß Using stored letter/mail content:', { 
          type: storedLetter.type, 
          hasContent: !!contentToShow,
          contentLength: contentToShow.length 
        });
        
        setLetterText(contentToShow);
        setCityName(storedLetter.fromCity || storedLetter.city || 'Tokyo');
        setCityImage(storedLetter.cityImage || '/letters/tokyo.png');
        setDiaryNotFound(false);
        
        // Create diary structure from stored letter
        const letterDiary = {
          id: 1,
          en: contentToShow,
          jp: storedLetter.jp,
          location: storedLetter.fromCity || storedLetter.city || 'Tokyo',
          cityName: storedLetter.fromCity || storedLetter.city || 'Êù±‰∫¨',
          cityImage: storedLetter.cityImage || '/letters/tokyo.png',
          type: storedLetter.type
        };
        setDiary(letterDiary);
        
        // Calculate word count
        const words = contentToShow.trim().split(/\s+/).filter((word: string) => word.length > 0);
        setWordCount(words.length);
        
        // Skip the rest if we have stored content
        console.log('üìß Successfully loaded stored letter/mail content');
        return;
      }
      
      // üìß FALLBACK: Use letterData[0] (Narita Airport letter) only if no stored content
      console.log('üìß No stored content found, using Narita fallback');
      const naritaLetter = letters[0];
      const userLevel = parseInt(localStorage.getItem('vocabLevel') || '1', 10);
      
      // Get appropriate English content using utility function
      const englishContent = getEnglishText(naritaLetter.en, userLevel);
      
      console.log('üìß Using Narita letter as fallback with level:', { userLevel, hasLevel: !!naritaLetter.en[userLevel] });
      
      // Set letterData content as fallback
      setLetterText(englishContent);
      setCityName('Tokyo');
      setCityImage('/letters/tokyo.png');
      setDiaryNotFound(false);
      
      // Create diary structure for compatibility
      const letterDiary = {
        id: 1,
        en: englishContent,
        jp: naritaLetter.jp,
        location: 'Tokyo',
        cityName: 'Êù±‰∫¨',
        cityImage: '/letters/tokyo.png'
      };
      setDiary(letterDiary);
      
      // Calculate word count
      const words = englishContent.trim().split(/\s+/).filter((word: string) => word.length > 0);
      setWordCount(words.length);

      if (id) {
        // Step 1: „Åæ„Åö localStorage „Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàdiary:<id> ÂΩ¢ÂºèÔºâ
        const diaryKey = `diary:${id}`;
        const savedDiary = localStorage.getItem(diaryKey);
        
        if (savedDiary) {
          try {
            const diaryData = JSON.parse(savedDiary);
            console.log('‚ö° Found in localStorage, immediate display:', diaryData);
            
            // Âç≥Â∫ß„Å´Ë°®Á§∫„Éá„Éº„Çø„Çí„Çª„ÉÉ„Éà
            setDiary(diaryData);
            setLetterText(diaryData.en || '');
            setCityName(diaryData.location || cityNameMap[diaryData.cityName] || 'Unknown');
            setCityImage(diaryData.cityImage || `/letters/${id}.png`);
            
            // Calculate word count
            const content = diaryData.en || '';
            const words = content.trim().split(/\s+/).filter((word: string) => word.length > 0);
            setWordCount(words.length);
            
            setDiaryNotFound(false);
            
            // Step 2: „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßAPI fetch„ÇíÂÆüË°åÔºàÈùûÂêåÊúü„ÄÅ„Éé„É≥„Éñ„É≠„ÉÉ„Ç≠„É≥„Ç∞Ôºâ
            getDiaryFromAPI(id).then(apiDiary => {
              if (apiDiary) {
                console.log('üîÑ Background update from API');
                // API „Éá„Éº„Çø„ÅßÊõ¥Êñ∞Ôºà„ÅÇ„Çå„Å∞Ôºâ
                setDiary(apiDiary);
                setLetterText(apiDiary.en || '');
                setCityName(apiDiary.location || cityNameMap[apiDiary.cityName] || 'Unknown');
                setCityImage(apiDiary.cityImage || `/letters/${id}.png`);
                
                const newContent = apiDiary.en || '';
                const newWords = newContent.trim().split(/\s+/).filter((word: string) => word.length > 0);
                setWordCount(newWords.length);
              }
            }).catch(error => {
              console.log('Background API fetch failed, but localStorage data already displayed:', error);
            });
            
          } catch (error) {
            console.error('Error parsing localStorage diary:', error);
            // „Éë„Éº„Çπ„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØAPI fetch„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
            await fetchFromAPIOnly(id);
          }
        } else {
          // Step 3: localStorage „Å´„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø API ÂèñÂæó„ÇíÂæÖÊ©ü
          console.log('‚è≥ No localStorage data, fetching from API...');
          await fetchFromAPIOnly(id);
        }
      } else {
        // URL„Å´id„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÂæìÊù•„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ
        handleNoIdCase();
      }
    };

    // API „ÅÆ„Åø„Åã„ÇâÂèñÂæó„Åô„ÇãÈñ¢Êï∞Ôºà„Éñ„É≠„ÉÉ„Ç≠„É≥„Ç∞Ôºâ
    const fetchFromAPIOnly = async (id: string) => {
      try {
        const apiDiary = await getDiaryFromAPI(id);
        
        if (apiDiary) {
          console.log('‚úÖ Loaded from API');
          setDiary(apiDiary);
          setLetterText(apiDiary.en || '');
          setCityName(apiDiary.location || cityNameMap[apiDiary.cityName] || 'Unknown');
          setCityImage(apiDiary.cityImage || `/letters/${id}.png`);
          
          const content = apiDiary.en || '';
          const words = content.trim().split(/\s+/).filter((word: string) => word.length > 0);
          setWordCount(words.length);
          
          setDiaryNotFound(false);
        } else {
          console.log('‚ùå Êó•Ë®ò„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì for id:', id);
          setDiaryNotFound(true);
        }
      } catch (error) {
        console.error('API fetch error:', error);
        setDiaryNotFound(true);
      }
    };

    // ID „Åå„Å™„ÅÑÂ†¥Âêà„ÅÆÂá¶ÁêÜ
    const handleNoIdCase = () => {
      // Use safe letter storage function instead of direct localStorage access
      const storedLetter = getLetterFromStorage();
      const userLevel = parseInt(localStorage.getItem('vocabLevel') || '1', 10);
      
      const savedCityImage = localStorage.getItem('cityImage') || '';
      const lastCity = localStorage.getItem('lastCity') || '';

      const fallbackLetterText = `Hello from your travel companion!

I'm writing to you from this amazing city. The culture here is fascinating and the people are incredibly welcoming.

I've been exploring the local markets and trying new foods. Every day brings a new adventure!

Looking forward to our next journey together.

Your Cat`;

      // Extract appropriate content from stored letter or use fallback
      let content = fallbackLetterText;
      if (storedLetter && storedLetter.en && storedLetter.en[userLevel]) {
        content = storedLetter.en[userLevel];
      } else if (storedLetter && storedLetter.en) {
        // Use first available level if exact level not found
        const availableLevels = Object.keys(storedLetter.en).map(Number);
        if (availableLevels.length > 0) {
          content = storedLetter.en[availableLevels[0]];
        }
      }
      setLetterText(content);
      setCityImage(savedCityImage || '/letters/tokyo.png');
      
      const words = content.trim().split(/\s+/).filter((word: string) => word.length > 0);
      setWordCount(words.length);
      
      setCityName(cityNameMap[lastCity] || lastCity || 'Tokyo');
      setDiaryNotFound(false);
    };

    loadDiary();
  }, [searchParams]);

  // WPMÂ±•Ê≠¥„ÅÆ‰øùÂ≠ò„Å®Âπ≥ÂùáË®àÁÆó
  const saveWPMHistory = (wpm: number) => {
    const wpmHistory = JSON.parse(localStorage.getItem('wpmHistory') || '[]');
    wpmHistory.push(wpm);
    // Áõ¥Ëøë5ÂõûÂàÜ„ÅÆ„Åø‰øùÊåÅ
    if (wpmHistory.length > 5) {
      wpmHistory.shift();
    }
    localStorage.setItem('wpmHistory', JSON.stringify(wpmHistory));
  };

  const getAverageWPM = (): number => {
    const wpmHistory = JSON.parse(localStorage.getItem('wpmHistory') || '[]');
    if (wpmHistory.length === 0) return 0;
    const sum = wpmHistory.reduce((acc: number, wpm: number) => acc + wpm, 0);
    return Math.round(sum / wpmHistory.length);
  };

  const handleStartReading = () => {
    setHasStarted(true);
    setStartTime(Date.now());
  };

  const handleComplete = () => {
    setIsCompleted(true);
    const currentTime = Date.now();
    setEndTime(currentTime);
    
    // Ë™≠Êõ∏ÊôÇÈñìË®àÁÆóÔºàË™ûÊï∞„Å´Èñ¢‰øÇ„Å™„ÅèË®àÁÆóÔºâ
    let duration = 0;
    if (startTime) {
      duration = currentTime - startTime; // „Éü„É™Áßí
      console.log('üìß Duration calculated:', { startTime, currentTime, duration, durationMinutes: duration / 60000 });
    } else {
      console.log('‚ö†Ô∏è startTime is null, cannot calculate duration');
    }
    
    // Ë™ûÊï∞Êõ¥Êñ∞
    const currentTotal = parseInt(localStorage.getItem('wordCount') || '0', 10);
    const newTotal = currentTotal + wordCount;
    localStorage.setItem('wordCount', newTotal.toString());
    
    // Êñ∞ÈÉΩÂ∏Ç„ÇíÂèñÂæó„Åó„Å¶‰øùÂ≠ò
    const nextCity = getNextCity(newTotal);
    localStorage.setItem('lastCity', nextCity.cityName);
    console.log('üó∫Ô∏è Ê¨°„Å´Ë®™„Çå„ÇãÈÉΩÂ∏Ç:', nextCity.cityName);

    // üìß Save mail/letter to history with proper metrics
    const storedLetter = getLetterFromStorage();
    if (storedLetter) {
      const userLevel = parseInt(localStorage.getItem('vocabLevel') || '1', 10);
      const catName = localStorage.getItem('catName') || 'Your cat';
      
      // Calculate actual word count from displayed content
      const actualContent = storedLetter.en[userLevel] || Object.values(storedLetter.en)[0] || '';
      const actualWordCount = actualContent.trim().split(/\s+/).filter((word: string) => word.length > 0).length;
      
      // Recalculate WPM with actual word count
      let actualWPM = 0;
      if (duration > 0 && actualWordCount > 0) {
        const timeInMinutes = duration / (1000 * 60);
        actualWPM = Math.round(actualWordCount / timeInMinutes);
        console.log('üìß WPM calculation:', { actualWordCount, duration, timeInMinutes, actualWPM });
      } else {
        console.log('‚ö†Ô∏è Cannot calculate WPM:', { duration, actualWordCount });
      }
      
      console.log('üìß Actual metrics calculated:', { 
        actualWordCount, 
        duration, 
        actualWPM,
        stateWordCount: wordCount 
      });
      
      if (storedLetter.type === 'mail') {
        // Save mail to history
        saveToHistory({
          type: "mail",
          title: `In-flight from ${storedLetter.fromCity || 'Tokyo'} to ${storedLetter.toCity || 'Seoul'}`,
          contentJP: storedLetter.jp,
          contentEN: actualContent,
          level: userLevel,
          wordCount: actualWordCount,
          duration: duration,
          wpm: actualWPM,
          fromCity: storedLetter.fromCity || 'Tokyo',
          toCity: storedLetter.toCity || 'Seoul',
          milestone: Math.round(parseInt(localStorage.getItem('elapsedReadingTime') || '0', 10) / 60000), // Convert to minutes
        });
        console.log('üìß Mail saved to history with metrics:', { wordCount: actualWordCount, duration, wpm: actualWPM });
      } else {
        // Save letter to history
        saveToHistory({
          type: "letter",
          title: `A letter from ${storedLetter.city || cityName}`,
          contentJP: storedLetter.jp,
          contentEN: actualContent,
          level: userLevel,
          wordCount: actualWordCount,
          duration: duration,
          wpm: actualWPM,
          city: storedLetter.city || cityName,
        });
        console.log('üìß Letter saved to history with metrics:', { wordCount: actualWordCount, duration, wpm: actualWPM });
      }
      
      // Update the displayed wordCount and WPM states with actual values
      setWordCount(actualWordCount);
      setCalculatedWPM(actualWPM);
      
      // Save WPM to history if valid
      if (actualWPM > 0) {
        saveWPMHistory(actualWPM);
        console.log('üìß WPM saved to history:', actualWPM);
      }
    }
  };

  const handleToggleTranslation = () => {
    setShowTranslation(!showTranslation);
  };

  const handleReadAgain = () => {
    setHasStarted(false);
    setIsCompleted(false);
    setShowTranslation(false);
  };

  const handleChooseNext = () => {
    router.push('/choose');
  };

  // üìß Part 3: Safe letter storage usage for display
  const userLevel = parseInt(localStorage.getItem('vocabLevel') || '1', 10);
  
  // Try to get letter from storage first, then fallback to letterData
  const storedLetter = getLetterFromStorage();
  const fallbackLetter = letters[0]; // Narita Airport letter as fallback
  
  let letter, englishText;
  
  if (storedLetter && storedLetter.en && storedLetter.en[userLevel]) {
    letter = storedLetter;
    englishText = storedLetter.en[userLevel];
    console.log('üìß Using stored letter with safe parsing');
  } else if (fallbackLetter) {
    letter = fallbackLetter;
    englishText = getEnglishText(fallbackLetter.en, userLevel);
    console.log('üìß Fallback to letterData');
  } else {
    console.error('üìß No letter available');
    letter = null;
    englishText = 'ÊâãÁ¥ô„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ';
  }
  
  console.log('üìß Safe letter usage:', { userLevel, letterExists: !!letter, englishLength: englishText.length });
  
  // Split letterText into paragraphs (ÊÆµËêΩÂàÜÂâ≤)
  console.log('üìÑ Letter page - diary:', diary);
  console.log('üìÑ Letter page - letterText:', letterText);
  console.log('üìÑ Letter page - diary?.en:', diary?.en);
  
  // Use safe letter content for display
  let contentToDisplay = englishText;
  console.log('üìÑ Using safe letter content');
  
  const enParagraphs = contentToDisplay
    ? contentToDisplay.split(/\n+/).filter(p => p.trim() !== '')
    : [];

  const jpParagraphs = letter && letter.jp
    ? letter.jp.split(/\n+/).filter(p => p.trim() !== '')
    : [];

  // max length „Å´Âêà„Çè„Åõ„Å¶„É´„Éº„Éó
  const pairedParagraphs = enParagraphs.map((en, idx) => ({
    en,
    jp: jpParagraphs[idx] || '', // ÂØæÂøú„Åô„ÇãÊó•Êú¨Ë™ûË®≥Ôºà„Å™„Åë„Çå„Å∞Á©∫Ôºâ
  }));
    
  console.log('üìÑ Letter page - contentToDisplay:', contentToDisplay);
  console.log('üìÑ Letter page - enParagraphs:', enParagraphs);
  console.log('üìÑ Letter page - jpParagraphs:', jpParagraphs);
  console.log('üìÑ Letter page - pairedParagraphs:', pairedParagraphs);

  return (
    <main className="min-h-screen bg-[#FFF9F0] flex flex-col items-center justify-center p-4">
      <div className="bg-white rounded-2xl shadow-lg p-8 max-w-2xl w-full">
        {showNotice && (
          <div className="mb-4 p-3 bg-green-100 border border-green-400 text-green-800 rounded shadow animate-fade-in">
            {(() => {
              const storedLetter = getLetterFromStorage();
              const isMailType = storedLetter?.type === 'mail';
              return isMailType ? '‚úâÔ∏è Êñ∞„Åó„ÅÑ„É°„Éº„É´„ÅåÂ±ä„Åç„Åæ„Åó„ÅüÔºÅ' : '‚ú® Êñ∞„Åó„ÅÑÊâãÁ¥ô„ÅåÂ±ä„Åç„Åæ„Åó„ÅüÔºÅ';
            })()}
          </div>
        )}
        {/* ‚ë† ÂãïÁöÑ„Çø„Ç§„Éà„É´ÔºöÊâãÁ¥ô„Éª„É°„Éº„É´ type „Å´Âøú„Åò„Å¶ÂàÜÂ≤ê */}
        <h1 className="text-3xl font-bold text-center text-gray-800 mb-8">
          {(() => {
            const letter = getLetterFromStorage();
            const catName = localStorage.getItem("catName") || "Your cat";
            
            if (letter?.type === "letter" && letter?.city) {
              return `üìÆ A letter from ${letter.city}`;
            } else if (letter?.type === "mail" && letter?.fromCity) {
              return `‚úâÔ∏è ${catName} „Åã„Çâ„ÅÆÊú™Ë™≠„É°„Éº„É´`;
            } else {
              return `üìÆ A Letter from ${cityName}`;
            }
          })()}
        </h1>

        {/* Êó•Ë®ò„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅÆË°®Á§∫ */}
        {diaryNotFound && (
          <div className="text-center py-8">
            <div className="text-6xl mb-4">üòø</div>
            <h2 className="text-2xl font-bold text-gray-800 mb-4">Êó•Ë®ò„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì</h2>
            <p className="text-gray-600 mb-6">
              ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆÊó•Ë®ò„ÅØÂ≠òÂú®„Åó„Å™„ÅÑ„Åã„ÄÅ„Åæ„Å†‰ΩúÊàê„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ
            </p>
            <button
              onClick={() => router.push('/choose')}
              className="bg-orange-400 hover:bg-orange-500 text-white font-semibold px-6 py-3 rounded-xl transition-colors duration-200"
            >
              üìö ‰ªñ„ÅÆ„ÇÇ„ÅÆ„ÇíË™≠„ÇÄ
            </button>
          </div>
        )}

        {/* ‚ë° „ÄåË™≠„ÅøÂßã„ÇÅ„Çã„Äç„Éú„Çø„É≥ÔºàÂàùÊúüË°®Á§∫„ÅÆ„ÅøÔºâ */}
        {!diaryNotFound && !hasStarted && (
          <div className="text-center mb-8">
            <button
              onClick={handleStartReading}
              className="bg-orange-400 text-white py-4 px-8 rounded-xl text-lg font-medium hover:bg-orange-500 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2"
            >
              üìñ Ë™≠„ÅøÂßã„ÇÅ„Çã
            </button>
          </div>
        )}

        {/* hasStarted = true „ÅÆ„Å®„Åç„Å´ÊâãÁ¥ôÂÜÖÂÆπ„Å®ÁîªÂÉè„ÇíË°®Á§∫ */}
        {!diaryNotFound && hasStarted && (
          <>
            {/* ÊâãÁ¥ôÊú¨ÊñáÔºàÊÆµËêΩÂàÜ„Åë + „ÇØ„É™„ÉÉ„ÇØÂèØËÉΩ„Å™Ë™ûÔºâ */}
            <div className="letter-content mb-8 space-y-6">
              {!letter?.en?.[userLevel] ? (
                <p className="text-red-600 text-center py-4">
                  ÊâãÁ¥ô„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ
                </p>
              ) : pairedParagraphs.length > 0 ? (
                pairedParagraphs.map((pair, index) => (
                  <div key={index}>
                    <p className="text-gray-700 leading-relaxed mb-1 text-lg">
                      {renderClickableText(pair.en)}
                    </p>
                    {showTranslation && (
                      <p className="text-gray-600 leading-relaxed text-sm">{pair.jp}</p>
                    )}
                  </div>
                ))
              ) : (
                <p className="text-gray-700 leading-relaxed">
                  No letter content available. Please check localStorage.
                </p>
              )}
            </div>

            {/* ‚úÖ Ë™≠‰∫Ü„Éú„Çø„É≥ÔºàÊâãÁ¥ô„Å®ÁîªÂÉè„ÅÆÈñìÔºâ */}
            {!isCompleted && (
              <div className="text-center mb-8">
                <button
                  onClick={handleComplete}
                  className="bg-orange-400 text-white py-3 px-6 rounded-xl font-medium hover:bg-orange-500 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2"
                >
                  ‚úÖ Ë™≠‰∫Ü
                </button>
              </div>
            )}

            {/* üìä ÈÄ≤ÊçóÊÉÖÂ†±„Åæ„Å®„ÇÅÔºàË™≠‰∫ÜÂæå„Å´Ë°®Á§∫Ôºâ */}
            {isCompleted && (
              <div className="bg-blue-50 border border-blue-200 rounded-xl p-6 mb-8">
                <h3 className="font-bold text-gray-800 mb-4 text-lg">üìä Ë™≠Êõ∏ÈÄ≤Êçó„Åæ„Å®„ÇÅ</h3>
                <div className="space-y-3 text-gray-700">
                  <p className="text-sm">‰ªäÂõû„ÅÆË™ûÊï∞Ôºö<span className="font-semibold">{wordCount}Ë™û</span></p>
                  <p className="text-sm">‰ªäÂõû„ÅÆWPMÔºö<span className="font-semibold">{calculatedWPM}</span></p>
                  <p className="text-sm">Âπ≥ÂùáWPMÔºàÁõ¥Ëøë5ÂõûÔºâÔºö<span className="font-semibold">{getAverageWPM()}</span></p>
                  <p className="text-sm">„Åì„Çå„Åæ„Åß„ÅÆÂêàË®àË™ûÊï∞Ôºö<span className="font-semibold">{(parseInt(localStorage.getItem('wordCount') || '0', 10)).toLocaleString()}Ë™û</span></p>
                  {(() => {
                    const totalWords = parseInt(localStorage.getItem('wordCount') || '0', 10);
                    const nextCity = getNextUnreachedCity(totalWords);
                    return nextCity ? (
                      <p className="text-sm">Ê¨°„ÅÆÁõÆÁöÑÂú∞Ôºö<span className="font-semibold">{nextCity.cityName}</span>Ôºà„ÅÇ„Å® <span className="font-semibold text-orange-600">{(nextCity.requiredWords - totalWords).toLocaleString()}Ë™û</span>Ôºâ</p>
                    ) : (
                      <p className="text-sm font-semibold text-green-600">üéâ „Åô„Åπ„Å¶„ÅÆÈÉΩÂ∏Ç„Å´Âà∞ÈÅîÊ∏à„Åø„Åß„ÅôÔºÅ</p>
                    );
                  })()}
                </div>
              </div>
            )}

            {/* ÈÉΩÂ∏ÇÁîªÂÉèÔºà„Éç„Ç≥ÂÖ•„ÇäÔºâ - photoTier„Åånone„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøË°®Á§∫ */}
            {cityImage && diary?.photoTier !== "none" && (
              <img 
                src={cityImage}
                alt="City illustration"
                className="w-full mt-4 rounded-xl mb-8"
                onError={(e) => {
                  (e.target as HTMLImageElement).style.display = 'none';
                }}
              />
            )}

            {/* Êó•Êú¨Ë™ûË®≥Ôºà„Éà„Ç∞„É´Ë°®Á§∫Ôºâ */}
          

            {/* ‚ë¶ Ë™≠‰∫ÜÂæå„Å´Ë°®Á§∫„Åô„Çã3„Å§„ÅÆ„Éú„Çø„É≥ */}
            {isCompleted && (
              <>
                <div className="flex flex-col md:flex-row justify-center gap-4 mt-6 mb-8">
                  <button 
                    onClick={handleToggleTranslation}
                    className="bg-purple-500 hover:bg-purple-600 text-white font-semibold px-6 py-2 rounded-xl transition-colors duration-200"
                  >
                    üåê Êó•Êú¨Ë™ûË®≥„ÇíË¶ã„Çã
                  </button>
                  <button 
                    onClick={handleReadAgain}
                    className="bg-sky-500 hover:bg-sky-600 text-white font-semibold px-6 py-2 rounded-xl transition-colors duration-200"
                  >
                    üîÅ „ÇÇ„ÅÜ‰∏ÄÂ∫¶Ë™≠„ÇÄ
                  </button>
                  <button 
                    onClick={handleChooseNext}
                    className="bg-orange-400 hover:bg-orange-500 text-white font-semibold px-6 py-2 rounded-xl transition-colors duration-200"
                  >
                    üìö ‰ªñ„ÅÆ„ÇÇ„ÅÆ„ÇíË™≠„ÇÄ
                  </button>
                </div>

                {/* ‰ªäÊó•„ÅÆ„Éû„Ç§„Éé„Éº„ÉàÔºàË™≠‰∫ÜÂæå„Å´Ë°®Á§∫Ôºâ */}
                {clickedWords.length > 0 && (
                  <div className="bg-[#FFF9F4] border border-[#C9A86C] rounded-xl p-6 mt-8">
                    <div className="flex items-center justify-between mb-4">
                      <h3 className="font-bold text-[#1E1E1E] text-lg">üìù ‰ªäÊó•„ÅÆ„Éû„Ç§„Éé„Éº„Éà</h3>
                    </div>
                    
                    <p className="text-sm text-[#1E1E1E] mb-4">
                      „ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÂçòË™û {clickedWords.length}ÂÄã
                    </p>
                    
                    <div className="space-y-3 mb-4">
                      {clickedWords.map((word, index) => (
                        <div key={index} className="bg-white rounded-lg p-3 border border-[#C9A86C]">
                          <div className="flex items-start justify-between">
                            <div className="flex-1">
                              <div className="space-y-2">
                                <div className="flex items-center space-x-2">
                                  <span className="font-bold text-lg text-[#1E1E1E]">{word.word}</span>
                                  {word.pos && (
                                    <span className="text-xs bg-[#FFE1B5] text-[#7E6944] px-2 py-1 rounded-full">
                                      {posMap[word.pos] || "‰∏çÊòé"}
                                    </span>
                                  )}
                                </div>
                                
                                <div className="text-sm text-[#1E1E1E]">
                                  <p className="font-medium">ÊÑèÂë≥Ôºö</p>
                                  <p>{word.jaDefinition || 'ÂÆöÁæ©„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì'}</p>
                                </div>
                                
                                {word.enExample && (
                                  <div className="text-sm text-[#1E1E1E]">
                                    <p className="font-medium">‰æãÊñáÔºö</p>
                                    <p className="italic">{word.enExample}</p>
                                    {word.jaExample && (
                                      <p className="text-xs text-gray-600 mt-1">{word.jaExample}</p>
                                    )}
                                  </div>
                                )}
                              </div>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                    
                    <button
                      onClick={() => window.location.href = '/notebook'}
                      className="w-full bg-[#FFE1B5] text-[#1E1E1E] px-6 py-3 rounded-md font-medium hover:bg-[#E5C590] transition-colors"
                    >
                      üìö „Éû„Ç§„Éé„Éº„Éà„ÇíË¶ã„Çã
                    </button>
                  </div>
                )}
              </>
            )}
          </>
        )}

        {/* Dictionary Modal - Only show when not reading */}
        {showDictionaryModal && wordInfo && !hasStarted && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-xl max-w-md w-full max-h-[80vh] overflow-y-auto">
              <div className="p-6">
                {/* Header */}
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-xl font-bold text-gray-800">üìñ ÂçòË™û„ÅÆÂÆöÁæ©</h3>
                  <button
                    onClick={() => setShowDictionaryModal(false)}
                    className="text-gray-500 hover:text-gray-700 text-2xl"
                  >
                    √ó
                  </button>
                </div>

                {/* Loading state */}
                {loadingWordInfo && (
                  <div className="text-center py-8">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-orange-400 mx-auto mb-2"></div>
                    <p className="text-gray-600">ÂÆöÁæ©„ÇíÂèñÂæó‰∏≠...</p>
                  </div>
                )}

                {/* Word definition content */}
                {!loadingWordInfo && wordInfo && (
                  <div className="space-y-4">
                    {/* Word header */}
                    <div className="border-b border-gray-200 pb-3">
                      <div className="flex items-center space-x-2 mb-2">
                        <span className="text-2xl font-bold text-gray-800">{wordInfo.word}</span>
                        {wordInfo.baseForm && wordInfo.baseForm !== wordInfo.word && (
                          <span className="text-sm text-gray-500">({wordInfo.baseForm})</span>
                        )}
                        {wordInfo.partOfSpeech && wordInfo.partOfSpeech !== 'unknown' && (
                          <span className="text-xs bg-orange-100 text-orange-700 px-2 py-1 rounded-full">
                            {wordInfo.partOfSpeech}
                          </span>
                        )}
                      </div>
                    </div>

                    {/* Meaning */}
                    <div>
                      <h4 className="font-semibold text-gray-700 mb-2">üîç ÊÑèÂë≥</h4>
                      <div className="space-y-2">
                        <p className="text-gray-800">
                          <span className="font-medium">Êó•Êú¨Ë™û:</span> {wordInfo.japaneseMeaning}
                        </p>
                        <p className="text-gray-600 text-sm">
                          <span className="font-medium">English:</span> {wordInfo.meaning}
                        </p>
                      </div>
                    </div>

                    {/* Example sentences */}
                    {(wordInfo.sentence || wordInfo.sentenceJapanese) && (
                      <div>
                        <h4 className="font-semibold text-gray-700 mb-2">üí≠ ‰æãÊñá</h4>
                        <div className="space-y-2">
                          {wordInfo.sentence && (
                            <p className="text-gray-800 italic">
                              "{wordInfo.sentence}"
                            </p>
                          )}
                          {wordInfo.sentenceJapanese && (
                            <p className="text-gray-600 text-sm">
                              "{wordInfo.sentenceJapanese}"
                            </p>
                          )}
                        </div>
                      </div>
                    )}

                    {/* Actions */}
                    <div className="pt-4 border-t border-gray-200">
                      <div className="flex space-x-3">
                        <button
                          onClick={() => setShowDictionaryModal(false)}
                          className="flex-1 bg-orange-400 hover:bg-orange-500 text-white py-2 px-4 rounded-lg font-medium transition-colors"
                        >
                          ‚úÖ OK
                        </button>
                        <button
                          onClick={() => window.location.href = '/notebook'}
                          className="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 px-4 rounded-lg font-medium transition-colors"
                        >
                          üìö „Éé„Éº„Éà„ÇíË¶ã„Çã
                        </button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        )}

        {/* Reading mode: Show clicked words counter */}
        {hasStarted && !isCompleted && clickedWords.length > 0 && (
          <div className="fixed bottom-4 right-4 bg-orange-100 border border-orange-300 rounded-lg px-4 py-2 shadow-lg">
            <div className="text-sm text-orange-700 font-medium">
              üìñ ‰øùÂ≠òÊ∏à„ÅøÂçòË™û: {clickedWords.length}ÂÄã
            </div>
            <div className="text-xs text-orange-600">
              ËæûÊõ∏„ÅØË™≠‰∫ÜÂæå„Å´Á¢∫Ë™ç„Åß„Åç„Åæ„Åô
            </div>
          </div>
        )}
      </div>
    </main>
  );
}

export default function LetterPage() {
  return (
    <Suspense fallback={<div className="min-h-screen bg-[#FFF9F0] flex items-center justify-center">Ë™≠„ÅøËæº„Åø‰∏≠...</div>}>
      <LetterPageContent />
    </Suspense>
  );
}